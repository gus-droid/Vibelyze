Originally for my project, I intended to use different programs like Pytorch and I was planning on importing a few different libraries. However, I found myself having a lot of difficulty with this approach as for some reason I was having a lot of trouble importing and downloading these other external programs. Therefore, I pivoted a bit. I still wanted to keep my idea as I wanted to combine film with CS knowledge. Therefore, since I already knew a bit about how sentiment analysis is done through research when I was trying to import libraries, I decided to build my own database. So, what I originally did was, go on IMDB and search for words that people typically use to make movie reviews, and I would use these words and assign them a positive, neutral, or negative sentiment in my emotions.txt file. This was the first file I created and I kept flooding the file with words until I could no longer think of any on my own or from IMDB. Then, I would ask Chatgpt to give me a list of words typically used in movie reviews and I would add these to my database eventually, I grew this database to over 1000+ words, each conveying a different sentiment. I even included certain slang words because I thought this would make the program more diverse by appealing to a younger demographic. So, this was my approach to sentiment analysis instead of improving libraries.
After this, I first test out my program by making a read.txt file and emotion.py file. I made a simple reader like the one done in Lecture 7 SQL, where I used with open to read the text in read.txt. I would just type different things and the program would be able to read it. This was just a small test I did to be able to see if the database was correct. Eventually, I got rid of this file and I just kept my emotion.py file.
I started by using the same code I used previously to read the emotions.txt file, and then I would clean these words by getting rid of any leading or trailing space so at the end my directory would just be the words and their associated sentiment. I named this function and then my load_emotions function. Also, I declared the directory first and then applied this process to add the words to the list.
After this, I created a function that would analyze the sentiment the user inputs. I named it analyze_sentiment and I also made my app.py file because since I wanted user inputs, I needed to use Flask framework. Additionally, I made an HTML and CSS file as well to make the user interface. Regardless, for my function, I decided on two approaches. After looking at many IMDB user reviews on movies, I realized that a lot of them at times just explicitly state a rating in their review. A lot of them would write like 7/10 and that was basically all of the sentiment analysis for the computer already. So, I made the computer prioritize searching for an explicit rating first and then if it detects none, it will then analyze the words using the database. Additionally, I accounted for user exaggeration. For example, if the user said something along the lines of "This was a 1000000/10 for me!!" I would count that as a really good film as well. The threshold I decided on was the one used by Rotton Tomatoes when deciding when a film should be fresh or not. I made it so that if the computer detects an explicit rating of 6/10 or higher, it will assume it is a good movie and should be recommended. If it is lower, it will say the opposite. For the sentiment analysis part, it iterates through every word the user inputs in the text box and searches for them in the directory or database. Then, if it finds the word there, it takes its corresponding assigned sentiment (positive, negative, neutral) and then sums them up for all 3. Then, depending on which is greater, the computer will determine if the overall sentiment is either more negative positive, or neutral and then make a recommendation. This accounts for a few complexities because sometimes when a person makes a movie review, they may say a lot of good comments and love the movie, but they may still have some critiques. So, the computer takes this into account and can determine if the critiques outweigh the good comments or not.
Then, I made a top movie list which I modeled from IMDB. I made this list and similar to the emotions.txt file, I assigned each movie a sentiment. However, since these are all on IMDB's greatest movies of all time list, I made all of them positive. This was done because I realized that if a user inputs a review by someone else who may not have liked a movie, it doesn't mean the entire movie is not worth recommending. So, for the greatest movies of all time, I made the computer tell the user this is a negative review but it's still generally recommended by most people.
Then, I realized that for some of those top 25 films like Star Wars and Lord of the Rings, they used roman numerals in their title. So, I wanted a way that would make this universal. Say, if the user inputs Lord of the Rings 2, it is the same as Lord of the Rings II for the computer. So, I imported re to help with this and created a list of a few roman numerals assigned them to a numebr and converted them so the computer can easily read them.
Then, for my app.py file, I imported the functions from emotion.py, and then the program handles POST requests when the user submits a review it generalizes the movie title entered, and outputs the right message to the user on whether to recommend a movie or not. Then, I created the user interface and front end of this application. I made an HTML and CSS file and I kind of went for a design that people would be used to. I sort of made it like a chatbot like Chatgpt and I made the overall program easy, clean, and simple to use. Additionally, I created a logo for this website by using DALLE and generating an image according to the theme of my project. Then, I imported this into my codespace and titled it Logos.png.
To conclude, these were all the design decisions I made as I was working on my project. I tried to emphasize different complexities in the back end, and I cared about the user experience in the front end.